# Oracle (DBeaver) 사용

dbeaver에서 사용한 oracle script를 여기에 적는다.

All_Object_Confirm

```
SELECT  'DROP TABLE ' || object_name || ' CASCADE CONSTRAINTS;'
FROM    user_objects
WHERE   object_type = 'TABLE';

SELECT  'DROP view ' || object_name || ' CASCADE CONSTRAINTS;'
FROM    user_objects
WHERE   object_type = 'VIEW';

SELECT 'DROP TABLE "' || TABLE_NAME || '" CASCADE CONSTRAINTS;' FROM user_tables;

DROP TABLE VIEW_TEST CASCADE CONSTRAINTS;
DROP view VIEW01 CASCADE CONSTRAINTS;

```

|| 으로 컬럼묶기 object_name으로 전체 object중에 테이블인지 view인지 아니면 딴거인지 내가 살짝만 편집해서 다룰수있다 결과를 복사하면 원하는거 바로삭제가능하게 만듬

## basic

CREATE OR REPLACE VIEW v_emp AS SELECT * FROM emp;
-- 본체가 바뀌면 뷰도 같이 바뀐다 
SELECT *FROM v_emp;

CREATE SEQUENCE sequence_test;

SELECT sequence_test.nextval FROM dual;  -- dual 오라클에서 사용하는 임시 테이블
-- 전체복제
CREATE TABLE myemp AS SELECT * FROM emp;  -- 복사

SELECT * FROM myemp;
-- drop table myemp;
-- 원하는 컬럼 복제
CREATE TABLE emps AS SELECT EMPNO,ENAME FROM emp;
SELECT * FROM emps;

-- 구조(컬럼) 복제
CREATE TABLE empall AS SELECT * FROM emp WHERE 1=2;
SELECT * FROM empall;

CREATE TABLE table_notnull01(
	ID CHAR(3) NOT NULL,
	NAME VARCHAR2(20)
);

INSERT INTO table_notnull01 
values(1,'donghe');

INSERT INTO table_notnull01 
values('donghe');

SELECT * from table_notnull01;

CREATE TABLE table_notnull02(
	id char(3),
	name varchar2(20),
	CONSTRAINT tn02_id_nn NOT NULL (id)
);

CREATE TABLE table_unique01(
	id char(3) UNIQUE,
	name varchar2(20)
);

CREATE TABLE TABLE_UNIQUE02(
 ID CHAR(3),
 NAME VARCHAR2(20),
 CONSTRAINT TU02_ID_UNQ UNIQUE (ID)
);


CREATE TABLE TABLE_UNIQUE03(
 ID CHAR(3),
 NAME VARCHAR2(20),
 CONSTRAINT TU03_ID_UNQ UNIQUE (ID, NAME)  -- 이러면 묶인 값이 유니크 하다는거
);

INSERT INTO table_unique01 
values('100','oracle');

INSERT INTO table_unique01
values('200','python');

INSERT INTO table_unique01 (name)
values('hadoop');

INSERT INTO table_unique01 (name)
values('spark');

SELECT * FROM TABLE_UNIQUE01;  -- NULL 은 같은 문자들이 아님 그냥 값이 없는건 아는데 왤몯ㄻㄴㅇㄻㄶ??

INSERT INTO TABLE_UNIQUE02 
values('100','oracle');

INSERT INTO TABLE_UNIQUE02 
values('200','python');

SELECT * FROM TABLE_UNIQUE02;

INSERT INTO table_unique03
values('100','oracle');

INSERT INTO table_unique03
values('100','python');

SELECT * FROM TABLE_UNIQUE03;

CREATE TABLE TABLE_UNIQUE04(
 ID CHAR(3),
 NAME VARCHAR2(20),
 CONSTRAINT TU04_ID_UNQ UNIQUE (ID),  -- 이러면 묶인 값이 유니크 하다는거
 CONSTRAINT TU04_nm_UNQ UNIQUE (NAME)  -- 이러면 묶인 값이 유니크 하다는거
);

INSERT INTO table_unique04
VALUES ('100','oracle');

INSERT INTO table_unique04
VALUES ('100','python');

-- unique + notnull  = 기본키
CREATE TABLE  table_pk01(
	id char(3) PRIMARY KEY,
	name varchar2(20)
);

CREATE TABLE table_pk02(
	id char(3),
	name varchar2(20),
	CONSTRAINT tp02_id_pk PRIMARY KEY (id)
);

CREATE TABLE table_pk03(
	id char(3),
	name varchar2(20),
	CONSTRAINT tp03_id_pk PRIMARY KEY (id,name)  -- 슈퍼키, 복합키  두개가 다 기본키가 되어버림
);

INSERT INTO table_pk01 
values('100','oracle');

INSERT INTO table_pk01 
values('200','python');

INSERT INTO table_pk01
VALUES('200','hadoop');

INSERT INTO table_pk01(name)
VALUES('hadoop');   -- 기본키 NULL 값

INSERT INTO table_pk02
VALUES ('100','oracle');

INSERT INTO table_pk02 
values('200','python');

INSERT INTO table_pk02 
values('200','hadoop');


INSERT INTO table_pk03 
values('100','oracle');

INSERT INTO table_pk03 
values('100','python');

INSERT INTO table_pk03 
values('hadoop');  -- NULL 값안됨


CREATE TABLE talbe_fk01(
	id char(3),
	name varchar2(20),
	pkid char(3) REFERENCES table_pk01 (id)
);


CREATE TABLE talbe_fk02(
	id char(3),
	name varchar2(20),
	pkid char(3),
	CONSTRAINT tf02_id_fk FOREIGN KEY (pkid) REFERENCES table_pk02 (id)  -- 머 같으면 위에꺼 쓰자 그냥 외래키랑 
);

INSERT INTO talbe_fk01
values('500','oracle','300');

SELECT * FROM talbe_fk01;

INSERT INTO talbe_fk02
values('100','hadoop','300');

SELECT * FROM talbe_fk02 ;
SELECT * FROM table_pk02 ;

CREATE TABLE table_check01(
	id char(3),
	name varchar2(20),
	marriage char(1) CHECK (marriage IN ('Y','N'))
);

CREATE TABLE TABLE_CHECK02(
 ID CHAR(3),
 NAME VARCHAR2(20),
 MARRIAGE CHAR(1),
 CONSTRAINT TC02_MG_CK CHECK (MARRIAGE IN ('Y','N'))
);


INSERT INTO table_check01 
values('100','oracle','Y');

INSERT INTO table_check01 
values('200','python','N'); -- Y,N만 들어감 

CREATE TABLE test (
	id varchar(10),
	pw char(10)
);
-- 퀴즈 1 
CREATE TABLE test01 AS SELECT * FROM emp;
CREATE TABLE test02 AS SELECT empno,ename FROM emp;
SELECT * FROM emp;
CREATE TABLE test03 AS SELECT empno,ename FROM emp;
SELECT * FROM test03;
--CREATE TABLE test03(m1,m2) AS SELECT empno,ename FROM emp;
CREATE TABLE test03 AS SELECT empno AS "m1",ename AS "m2" FROM emp;
ALTER TABLE test03 RENAME COLUMN empno TO m1 ;
ALTER TABLE test03 RENAME COLUMN ename TO m2 ;
CREATE TABLE test04 AS SELECT * FROM emp WHERE 1=2;
SELECT * FROM test04;
CREATE TABLE test05 AS SELECT * FROM dept WHERE 1=2;


SELECT * FROM emp;
SELECT * FROM dept;

SELECT deptno FROM dept UNION SELECT deptno FROM emp;

SELECT deptno FROM dept UNION ALL SELECT deptno FROM emp;

SELECT deptno FROM dept INTERSECT SELECT deptno FROM emp;

SELECT deptno FROM dept MINUS SELECT deptno FROM emp;

-- 컴퓨터 시계에 따라 모양이 조금 다르게 나올수도있음 
SELECT sysdate FROM dual;


SELECT * FROM test01; 
 -- 이름이 ward인 사원의 월급을 2000으로 바꾸자 test01 테이블
UPDATE test01
SET sal = 2000 
WHERE ename = 'WARD';

-- test01 d이름이 ward 인 사원의 직업을 manager 바꾸고 부서를 20으로
UPDATE test01 SET job = 'MANAGER' , DEPTNO = 20 WHERE ENAME = 'WARD';

SELECT * FROM EMP;

SELECT ENAME,EMPNO,SAL FROM EMP;

SELECT ENAME,SAL*12 FROM EMP;

SELECT ENAME,HIREDATE,DEPTNO FROM EMP;

SELECT ENAME,MGR FROM EMP;

SELECT ENAME,SAL,COMM FROM EMP;

SELECT ENAME||'님이'||HIREDATE||'에 입사를 하고' ||SAL||'의 월급을 받습니다' FROM EMP; 



SELECT EMPNO || ENAME FROM EMP; -- 합치기
SELECT EMPNO || ENAME AS "test" FROM EMP; -- 별칭 쌍따옴표
SELECT sal + comm FROM emp; -- NULL 은 연산 안됨 

SELECT empno , ename , sal FROM emp WHERE empno = '7844';

SELECT empno , ename , sal FROM emp WHERE ename = 'SMITH';

SELECT * FROM emp WHERE hiredate  = '1980-12-17';

SELECT ename,hiredate FROM emp WHERE hiredate  BETWEEN '1980-01-01'AND '1982-12-30';

SELECT ename,sal FROM emp WHERE sal <= 2000;
SELECT ename,sal FROM emp WHERE sal BETWEEN 1000 AND 2000;
SELECT ename,sal FROM emp WHERE empno = '7369'OR empno='7499' OR empno='7521';
--  in (7369,7499,7521)

SELECT * FROM emp;
SELECT ename,sal FROM emp ORDER BY sal DESC;

SELECT job ,avg(sal) AS "평균" FROM emp GROUP BY job ORDER BY avg(sal) DESC  ;
															-- 2 도 가능 2번째 컬럼이란거 같음 
SELECT avg(sal) FROM emp;

SELECT deptno,avg(sal) FROM emp GROUP BY deptno having deptno = 10;

SELECT job,avg(sal) FROM emp GROUP BY job;

SELECT max(sal) FROM emp WHERE deptno = 10;

SELECT max(sal) FROM emp GROUP BY deptno;

SELECT job,sum(sal) FROM emp GROUP BY job HAVING sum(sal) >= 5000;

SELECT deptno ,sum(sal)
FROM emp
WHERE deptno <> 30
GROUP BY deptno
HAVING sum(sal) >= 8000
ORDER BY 2 DESC;

SELECT * FROM emp;
SELECT * FROM dept;
SELECT * FROM salgrade;

SELECT job,max(sal) AS "sal최대" ,min(sal) AS "sal최소" FROM emp GROUP BY job HAVING avg(sal)>1500 ;

SELECT dname FROM dept WHERE deptno = 20 OR deptno = 40;

SELECT losal  FROM salgrade  WHERE hisal BETWEEN 2000 AND 9000;

SELECT empno,ename FROM emp ORDER BY hiredate DESC;

CREATE TABLE human(
	name varchar2 (10),
	gender char(1),
	CHECK (gender IN ('M','F'))
);


-- 3월 07일 
-- npad(x,n,y) n 이 전체 크기 
SELECT lpad(ename,7,'*') FROM emp;

SELECT rpad(ename,10,'*') FROM emp; 
-- trim 처음 만나는 순간부터 L,R 부터 FALSE를 만난순간에 바로 멈춤
SELECT LTRIM('xyxzyyTech6xzyxzxy 327','xyz') FROM dual;  -- 한  묶음이 아니라 x이거나 y이거나 z라는거 를 왼쪽부터 삭제 한번 멈추면 끝임

SELECT RTRIM('xyxzyyTech6 327','0123456789') FROM DUAL; --공백 
SELECT RTRIM('xyxzyyTech6 327',' 0123456789') FROM DUAL; 

SELECT TRIM ('x'FROM 'xyxzyyTech6 327') FROM DUAL;

-- SELECT TRIM('xy' FROM 'xyxzyyTech6 327') FROM DUAL; -- 트림은 문자 하나만

SELECT ename,SUBSTR(ename,2,1) as"q1",SUBSTR(ename,-2) AS "q2"  FROM emp ; -- [] 머임?

SELECT ename,instr(ename,'S',1,1) FROM emp;

SELECT ENAME,INSTR(ENAME,'L',-1,2) FROM EMP; -- 뒤에서부터 2개 나오는 위치 

SELECT instr('abcccva','a',-1,2) FROM dual; -- 문자도 가능 

SELECT round(123.556),round(123.456,1),trunc(123.456,1),trunc(123.456,-1) FROM dual;

SELECT ceil(123.456) FROM dual;
SELECT floor(123.456) FROM DUAL; -- SELECT floor(123.456, 1) FROM DUAL;
SELECT CEIL(SAL / 1000) FROM EMP;
SELECT FLOOR(SAL / 1000) FROM EMP

SELECT ceil(sal/1000),floor(sal/1000),sal FROM emp;

SELECT ename,hiredate,ADD_MONTHS(hiredate,240)  FROM emp;

SELECT ename,job,HIREDATE ,
trunc(MONTHS_BETWEEN('2000/01/01',HIREDATE)/12) -- 1 부터 , 2까지 개월수 변환
FROM EMP 
WHERE MONTHS_BETWEEN('2000/01/01',HIREDATE) > 120;

SELECT
TO_CHAR(1234,'99999') AS q1,
to_char(1234,'00000') AS q2,
to_char(1234,'l9999') AS q3,
to_char(1234,'9,999') AS q4
FROM dual;

SELECT 
to_char(sysdate,'HH24:MI:SS') AS Q1,
to_char(sysdate,'MON DY,YYYY') AS Q2,
TO_CHAR(SYSDATE,'YYYY-FMMM-DD DAY')AS Q3,   -- FM이 0,공백? 암튼 그런거 지워줌 
TO_CHAR(SYSDATE,'YYYY-MM-DD') AS Q4,
TO_CHAR(SYSDATE,'YEAR , Q') AS Q5
FROM DUAL;
-- ???? 
SELECT TO_DATE('20100101','YYYYMMDD') FROM DUAL;
SELECT TO_CHAR(TO_DATE('20100101','YYYYMMDD'),'YYYY, MON') FROM DUAL;
SELECT TO_CHAR( TO_DATE('210830 143001', 'YYMMDD HH24MISS'), 
 'YY-MM-DD PM FMHH:MI:SS' )
FROM DUAL;

SELECT HIREDATE FROM EMP;
SELECT SYSDATE  FROM dual; -- 컴퓨터 날짜 형식 확인  cmd랑 여기랑 살ㅉ가 다름 
SELECT ename,HIREDATE,SUBSTR(HIREDATE,1,2) ,TO_number(SUBSTR(HIREDATE,4,2))  FROM emp; -- TO_number 숫자로 변환 

-- 사원 테이블에서 직업이 MANAGER인 사원은 1, SALESMAN 인 사원은 2, 아니면 0 을 출력하자.
-- 단순 값비교는 디코드가 편함
SELECT ename, job,decode(job,'MANAGER','1','SALESMAN','2','0') FROM emp;  -- 숫자로 해도됨 

SELECT CASE WHEN JOB = 'MANAGER' THEN 1 WHEN JOB = 'SALESMAN' THEN 2 ELSE 0 END AS TEST ,JOB FROM EMP;

-- 크거나 같다 이런식 
SELECT ENAME, SAL, CASE WHEN SAL <=	1000 THEN '초급'
 WHEN SAL <= 2000 THEN '중급' ELSE '고급' END
FROM EMP;

-- 필요에 따라 NULL값 대체 필요
SELECT COUNT(COMM),COUNT(NVL(COMM,0)) FROM EMP; -- NULL 차이 원래 집계의 NULL은 카운트 안함 근데 0으로 바꿔서 해부는거

SELECT SAL*12+NVL(COMM,0) FROM EMP; -- W같은 연봉이네 ^^

-- JOB과 DEPTNO 에 대한 집계 JOB에 대한 집계 -> 마지막에 전체 집계
SELECT JOB,DEPTNO,AVG(SAL) FROM EMP GROUP BY ROLLUP(JOB,DEPTNO);

SELECT JOB,DEPTNO,AVG(SAL) FROM EMP GROUP BY CUBE(JOB,DEPTNO);

-- GROUPING SETS() 원하는 집계 추가  B에대한 집계도 추가해줌 
SELECT JOB,DEPTNO,AVG(SAL) FROM EMP GROUP BY GROUPING SETS(ROLLUP(JOB,DEPTNO),DEPTNO);

CREATE TABLE ROWTEST(
	NO NUMBER
);

INSERT INTO ROWTEST
VALUES(111);

INSERT INTO ROWTEST
VALUES(222);

INSERT INTO ROWTEST
VALUES(333);

SELECT * FROM ROWTEST;

SELECT ROWID,ROWNUM, NO FROM ROWTEST; -- ID는 지워지지만 NUM은 그저 인덱스로 남아있음 

DELETE FROM ROWTEST
WHERE NO = 3;

SELECT ename,sal,rownum
FROM (SELECT ename,sal FROM emp ORDER BY sal DESC)  --() 이 가상테이블 inline view
WHERE rownum <= 3;  -- 3은 안찍힌다 1은 찍힘 3을 가져오는순간 rownum이 1이 되어버림 

SELECT ename,sal,rn
from (SELECT ename,sal,rownum AS rn
FROM (SELECT ename,sal FROM emp ORDER BY sal DESC))
WHERE rn >= 3 AND rn <= 5;  -- 이리하면 나옴 

SELECT ename,sal,rn
FROM (SELECT ename,sal,rownum AS rn
FROM (SELECT ename,sal  FROM emp ORDER BY sal desc))
WHERE rn = 3;


SELECT ename,sal ,
	rank() over(ORDER BY sal desc) AS RANK,
	dense_rank() over(ORDER BY sal desc) as dense,
	ROW_NUMBER () over(ORDER BY sal desc) AS rownb
FROM emp;



SELECT INITCAP(ENAME)  FROM EMP;
SELECT ename,SUBSTR(ename,2,3) FROM emp;
SELECT SYSDATE - HIREDATE,trunc(MONTHS_BETWEEN(SYSDATE,HIREDATE)*30)  FROM emp;
SELECT LENGTH(ename)  FROM emp;
SELECT ename FROM emp WHERE ENAME LIKE 'M%';

SELECT ENAME,SAL  -- 가상테이블 활용 
FROM EMP
WHERE SAL > (SELECT sal FROM emp WHERE ename = 'JONES');

-- 약간 FILLNA 같은느낌?? 
SELECT NVL(MGR,0) FROM EMP;

SELECT empno,ename 
FROM EMP 
WHERE empno NOT in (SELECT NVL(MGR,0) FROM EMP);  --SELECT NVL(MGR,0) FROM EMP; 여기에서 나오는값이 여러개임 그래서 안됨 그래서 != 이 아니라 IN , NOT IN 으로 써야함

SELECT ename,sal,deptno
FROM emp
WHERE (deptno,sal) IN (SELECT deptno,sal FROM emp WHERE job = 'SALESMAN' );

SELECT DEPTNO,AVG(SAL) FROM EMP GROUP BY DEPTNO;

-- 가상 테이블 힘들다! INLINE VIEW 할때 어떤 테이블에 어떤 컬럼을 명시하고 있는지 명확히 확인해야함 
SELECT E.ENAME,E.SAL,MYDEPT.DEPTNO,MYDEPT.MYAVG  
FROM EMP E,
	(SELECT DEPTNO,AVG(SAL) AS MYAVG FROM EMP GROUP BY DEPTNO) MYDEPT
WHERE E.DEPTNO = MYDEPT.DEPTNO
AND E.SAL > MYAVG;

-- 서브쿼리란 말은 WHERE 절에서 서브쿼리를 쓰는거? FROM 에서 쓰면 JOIN 이고 
SELECT * FROM emp;
-- Q subquery
SELECT * FROM SALGRADE;
SELECT * FROM EMP;
SELECT * FROM DEPT;
 -- JOIN 으로 푼거임 
SELECT E.ENAME,E.SAL
FROM EMP E,
(SELECT DEPTNO FROM DEPT WHERE LOC = 'CHICAGO') L
WHERE E.DEPTNO = L.DEPTNO;

SELECT ENAME,SAL FROM EMP 
WHERE MGR = (SELECT EMPNO FROM emp WHERE ename = 'KING');

SELECT E.ENAME,E.SAL FROM EMP E,(SELECT ENAME,SAL AS S FROM EMP WHERE DEPTNO = 20)
WHERE E.SAL > S;

-- ANY 는 OR 로  X < ALL ALL 에있는 최소값보다 작아야함  X < ANY ANY중에 가장 큰값보다 작으면 
-- 맞추기는함 ㅋㅋ 
SELECT E.ENAME,E.SAL 
FROM EMP E,
(SELECT ENAME,SAL AS S,RN
FROM (SELECT ENAME,SAL ,ROWNUM AS RN
FROM (SELECT ENAME,SAL FROM EMP WHERE JOB = 'SALESMAN' ORDER BY SAL DESC))
WHERE RN = 1)
WHERE E.SAL > S;

SELECT LOC 
FROM DEPT D,
(SELECT ENAME,DEPTNO FROM EMP WHERE ENAME = 'BLAKE') E
WHERE D.DEPTNO = E.DEPTNO ;


SELECT E.ENAME,E.DEPTNO,E.SAL FROM EMP E,
(SELECT JOB,ENAME,AVG(SAL) AS AVGSAL FROM EMP GROUP BY JOB,ENAME) J
WHERE E.ENAME LIKE '%S%' AND E.SAL > AVGSAL;

SELECT JOB,ENAME FROM EMP WHERE DEPTNO='7369'
SELECT E.ENAME,E.SAL FROM EMP E,
(SELECT ENAME,JOB,SAL AS S FROM EMP WHERE DEPTNO = '7876')
WHERE E.SAL > S;

{}
-- Q subquery
SELECT ENAME,SAL
FROM EMP
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'CHICAGO');

SELECT ENAME,SAL
FROM EMP
WHERE MGR = (SELECT EMPNO FROM EMP WHERE ENAME = 'KING');

SELECT ENAME,SAL FROM EMP
WHERE SAL > ALL (SELECT SAL FROM EMP WHERE DEPTNO = 20);

SELECT LOC FROM DEPT
WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'BLAKE');

SELECT EMPNO,ENAME,SAL FROM EMP
WHERE ENAME LIKE '%S%'
AND SAL > (SELECT AVG(SAL) FROM EMP  );
-- NONO
SELECT ENAME,JOB FROM EMP
WHERE JOB = (SELECT JOB FROM EMP WHERE EMPNO = 7369)
AND SAL > (SELECT SAL FROM EMP WHERE EMPNO = 7876);
{}



SELECT * FROM EMP;
SELECT * FROM SALGRADE;

SELECT ENAME,SAL,GRADE
FROM EMP JOIN SALGRADE ON (SAL BETWEEN LOSAL AND HISAL);  -- A B 사이 C
-- 오라클 쿼리 
SELECT ENAME,SAL,GRADE
FROM EMP E, SALGRADE S
WHERE SAL BETWEEN LOSAL AND HISAL;

-- SELF
SELECT 사원.ENAME,사원.EMPNO,관리자.ENAME,관리자.EMPNO
FROM EMP 사원, EMP 관리자
WHERE 사원.MGR = 관리자.EMPNO(+);

SELECT 사원.ENAME,사원.EMPNO,관리자.ENAME,관리자.EMPNO
FROM  EMP 사원 LEFT OUTER JOIN EMP 관리자 ON (사원.MGR = 관리자.EMPNO);

SELECT * FROM EMP;
SELECT * FROM DEPT;
SELECT * FROM SALGRADE;

SELECT  e.ename,e.deptno,d.dname
FROM emp e JOIN dept d on(e.deptno = d.deptno);

SELECT E.ENAME,E.JOB,dd.loc,E.DEPTNO FROM EMP E,(SELECT LOC,DEPTNO AS DE FROM DEPT WHERE LOC = 'DALLAS') dd
WHERE E.DEPTNO = DE;

SELECT ENAME,DEPTNO FROM EMP WHERE ENAME LIKE '%A%'


SELECT e.ename,d.dname,e.sal
FROM emp e  JOIN dept d on(e.deptno = d.deptno)
AND e.sal >= 3000;



SELECT EMPNO,ENAME,SAL*12,GRADE
FROM EMP JOIN SALGRADE ON (SAL BETWEEN LOSAL AND HISAL);

SELECT empno,ename,sal*12,sal*12+nvl(comm,0),sg.grade
FROM emp e JOIN salgrade sg ON e.sal BETWEEN sg.LOSAL AND sg.HISAL 
WHERE comm IS NOT NULL;

SELECT *
FROM emp e, SALGRADE sg
WHERE e.sal BETWEEN sg.LOSAL AND sg.HISAL 
AND e.comm IS NOT NULL;


SELECT *
FROM dept JOIN emp using(deptno) JOIN SALGRADE  on(sal BETWEEN losal AND hisal)
WHERE deptno = 10;

SELECT *
FROM dept d,emp e, salgrade sg
WHERE d.deptno = e.deptno 
AND e.sal BETWEEN sg.losal AND sg.HISAL 
AND e.DEPTNO = 10;

SELECT deptno,dname,ename,grade
FROM dept JOIN emp using(deptno) JOIN salgrade ON sal BETWEEN losal AND hisal
WHERE deptno = 10 OR deptno = 20
ORDER BY deptno ASC, sal DESC; 
-- where deptno in(10,20)

SELECT d.deptno,d.dname, e.ename, sg.grade
FROM dept d, emp e, salgrade sg 
WHERE d.deptno = e.deptno
AND e.sal BETWEEN sg.losal AND sg.HISAL 
AND (d.deptno = 10 OR d.deptno = 20)
ORDER BY deptno ASC, sal DESC; 


SELECT E.EMPNO,E.ENAME,EE.EMPNO,EE.ENAME FROM EMP E,(SELECT EMPNO,ENAME FROM EMP WHERE JOB = 'MANAGER') EE;
SELECT E.EMPNO,E.ENAME,EE.EMPNO,EE.ENAME FROM EMP E LEFT OUTER JOIN EMP EE ON (EE.JOB = 'MANAGER');  --?????????????????????

SELECT e.ename,e.empno,ee.empno,ee.ename
FROM emp e JOIN emp ee ON (e.mgr = ee.empno);

SELECT e.ename,e.empno,ee.empno,ee.ename
FROM emp e , emp ee
WHERE e.mgr = ee.empno;




SELECT JOB,LOC,AVG(SAL) FROM EMP LEFT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO GROUP BY JOB,LOC; 

SELECT dname,loc,count(*),avg(sal)
FROM emp JOIN dept using(deptno)
GROUP BY dname,loc;

SELECT d.dname,d.loc,count(*),avg(e.sal)
FROM emp e, dept d
WHERE e.deptno = d.deptno
GROUP BY d.dname,d.loc;

SELECT * FROM emp;
SELECT * FROM dept;


-- JOIN 이런거 없이 바로 별칭 붙이면 오라클 문법
-- Q JOIN
SELECT * FROM EMP;
SELECT * FROM DEPT;
SELECT * FROM SALGRADE;
-- 1 O
SELECT ENAME,DEPTNO,DNAME FROM EMP JOIN DEPT USING(DEPTNO);

SELECT e.ename, e.deptno, d.dname
FROM emp e JOIN dept d on(e.deptno = d.deptno);

SELECT e.ename, d.deptno, d.dname
FROM emp e, dept d
WHERE e.deptno = d.deptno;

-- 2 O
SELECT E.ENAME,E.JOB,E.DEPTNO,D.DNAME 
FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
WHERE D.LOC = 'DALLAS';
-- 2 ORACLE
SELECT E.ENAME,E.JOB,E.DEPTNO,D.DNAME 
FROM EMP E , DEPT D 
WHERE D.LOC = 'DALLAS' AND E.DEPTNO = D.DEPTNO ;

-- 3
SELECT ENAME,DNAME FROM EMP JOIN DEPT USING(DEPTNO)
WHERE ENAME LIKE '%A%';
-- 3 ORACLE
SELECT E.ENAME,D.DNAME FROM EMP E,DEPT D
WHERE ENAME LIKE '%A%' AND E.DEPTNO = D.DEPTNO ;

-- 4
SELECT ENAME,DNAME,SAL FROM EMP JOIN DEPT USING(DEPTNO)
WHERE SAL >= 3000;
-- 오라클 너무 똑같아서 안함

-- 5 NONO
SELECT EMPNO,ENAME,SAL*12,SAL*12+NVL(COMM,0) ,GRADE
FROM EMP E JOIN SALGRADE S ON (SAL BETWEEN LOSAL AND HISAL)
WHERE COMM IS NOT NULL;
-- 5 ORACLE
SELECT EMPNO,ENAME,SAL*12,SAL*12+NVL(COMM,0) ,GRADE
FROM EMP E, SALGRADE S 
WHERE e.sal BETWEEN sg.LOSAL AND sg.HISAL 
AND e.comm IS NOT NULL;

-- 6  ???
SELECT D.DEPTNO,D.DNAME,E.ENAME,E.SAL,S.GRADE
FROM DEPT D JOIN EMP E JOIN SALGRADE S ON(E.SAL BETWEEN S.LOSAL AND S.HISAL)
WHERE DEPTNO = 10;

SELECT deptno, dname, ename, sal, grade
FROM dept JOIN emp using(deptno) JOIN salgrade ON (sal BETWEEN losal AND hisal)
WHERE deptno = 10;


-- 7
SELECT DEPTNO,DNAME,ENAME,GRADE
FROM EMP JOIN DEPT USING(DEPTNO) JOIN SALGRADE ON(SAL BETWEEN LOSAL AND HISAL)
AND (DEPTNO = 10 OR DEPTNO = 20)
ORDER BY DEPTNO ASC, SAL DESC;

-- 8
SELECT E.EMPNO,E.ENAME,EE.EMPNO,EE.ENAME
FROM EMP E LEFT OUTER JOIN EMP EE ON (E.MGR = EE.EMPNO);

-- 9
SELECT DNAME,LOC,COUNT(*),AVG(SAL)
FROM EMP JOIN DEPT USING(DEPTNO)
GROUP BY DNAME,LOC;



## hr

--hr.txt
SELECT * FROM employees;
SELECT * FROM departments;
SELECT * FROM locations;
SELECT * FROM countries;
SELECT * FROM regions;
SELECT * FROM jobs;
SELECT * FROM job_history;

--1
SELECT first_name || last_name AS FULL_NAME ,email||'@HR.COM' FROM EMPLOYEES ;

--2
SELECT FIRST_NAME,EMPLOYEE_ID FROM EMPLOYEES
WHERE SUBSTR(HIRE_DATE,1,2) >= '06';
--3
SELECT FIRST_NAME ,DEPARTMENT_NAME ,L.STREET_ADDRESS,C.COUNTRY_NAME
FROM EMPLOYEES JOIN departments USING(DEPARTMENT_ID) JOIN LOCATIONS L USING(LOCATION_ID)
JOIN COUNTRIES C ON (L.COUNTRY_ID  = C.COUNTRY_ID);
--4 서브쿼리로 사용했어야함 
SELECT EMPLOYEE_ID ,FIRST_NAME 
FROM EMPLOYEES 
WHERE MANAGER_ID =
(SELECT EMPLOYEE_ID
FROM EMPLOYEES 
WHERE DEPARTMENT_ID = 90 AND PHONE_NUMBER LIKE '515%' AND PHONE_NUMBER LIKE '%4567');

--5
SELECT FIRST_NAME ,L.CITY , L.STREET_ADDRESS || ' ' ||L.POSTAL_CODE AS ADDRESS
FROM EMPLOYEES JOIN departments USING(DEPARTMENT_ID) JOIN LOCATIONS L USING(LOCATION_ID)
WHERE PHONE_NUMBER = '650.121.8009';
--6
SELECT FIRST_NAME ,C.COUNTRY_NAME ,SALARY,L.CITY
FROM EMPLOYEES JOIN departments USING(DEPARTMENT_ID) JOIN LOCATIONS L USING(LOCATION_ID)
JOIN COUNTRIES C ON (L.COUNTRY_ID  = C.COUNTRY_ID)
WHERE C.COUNTRY_NAME = 'Canada';

--7
SELECT *
FROM EMPLOYEES 
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME = 'Guy')
AND JOB_ID NOT IN (SELECT JOB_ID FROM EMPLOYEES WHERE FIRST_NAME = 'Guy' );

-- 8 과거직업 어케암?? ㄷㄷㄷ 
SELECT FIRST_NAME ,JH.JOB_ID AS 과거직업,E.JOB_ID AS 현재직업
FROM JOB_HISTORY jh JOIN EMPLOYEES e using(EMPLOYEE_ID)
WHERE END_DATE ='06/07/24';

--9
SELECT DEPARTMENT_NAME  ,DEPARTMENT_ID 
FROM DEPARTMENTS  
WHERE MANAGER_ID IS NULL;

--10 관리자니까 매니저랑 엮어야함 
SELECT LAST_NAME ,SALARY 
FROM EMPLOYEES 
WHERE EMPLOYEE_ID  IN (SELECT MANAGER_ID  
FROM DEPARTMENTS
WHERE DEPARTMENT_NAME = 'IT');

SELECT LAST_NAME,SALARY 
FROM EMPLOYEES E JOIN DEPARTMENTS D ON(E.EMPLOYEE_ID = D.MANAGER_ID)
WHERE D.DEPARTMENT_NAME = 'IT' AND E.DEPARTMENT_ID = D.DEPARTMENT_ID ;

-- 11 
SELECT CITY ,RN 
FROM(SELECT CITY,ROWNUM AS RN
FROM (SELECT CITY ,COUNT(*)
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) JOIN LOCATIONS USING(LOCATION_ID)
GROUP BY CITY
ORDER BY COUNT(*) DESC))
WHERE RN = 1;
-- 답
SELECT CITY,CNT,ROWNUM
FROM 
	(SELECT CITY,COUNT(*) AS CNT
	FROM DEPARTMENTS JOIN LOCATIONS USING(LOCATION_ID)
	WHERE DEPARTMENT_ID IN
		(SELECT DEPARTMENT_ID 
		FROM DEPARTMENTS 
		WHERE MANAGER_ID IS NOT NULL)
	GROUP BY CITY
	ORDER BY COUNT(*) DESC)
WHERE ROWNUM = 1;

--12
SELECT HIRE_DATE 
FROM EMPLOYEES 
WHERE SUBSTR(ADD_MONTHS(HIRE_DATE,120),1,2) = 18;

--13
SELECT FIRST_NAME ,EMPLOYEE_ID ,PHONE_NUMBER 
FROM EMPLOYEES 
WHERE SUBSTR(FIRST_NAME,1,1) = 'S';

--14
SELECT SUM(SALARY)
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) JOIN LOCATIONS USING(LOCATION_ID)
WHERE SUBSTR(HIRE_DATE,1,2) > '04' AND CITY = 'Seattle';

--15
SELECT FIRST_NAME,SALARY  
FROM EMPLOYEES
WHERE SUBSTR(HIRE_DATE,4,2) = '09'
AND SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES );


--16
SELECT LAST_NAME || FIRST_NAME AS FULL_NAME 
FROM EMPLOYEES 
WHERE SUBSTR(LAST_NAME,3,1) = 'c' OR SUBSTR(LAST_NAME,3,1) = 'C';

-- 17
SELECT FIRST_NAME ,JOB_ID ,HIRE_DATE 
FROM EMPLOYEES 
WHERE DEPARTMENT_ID IS NULL;

--18
SELECT FIRST_NAME ,SALARY 
FROM EMPLOYEES
WHERE SALARY > ALL (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Kevin') 
AND SALARY < ALL (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Susan');

-- 19
SELECT CITY,COUNTRY_NAME ,REGION_NAME
FROM EMPLOYEES FULL OUTER JOIN DEPARTMENTS USING(DEPARTMENT_ID) FULL OUTER JOIN LOCATIONS USING(LOCATION_ID)
FULL OUTER JOIN COUNTRIES USING(COUNTRY_ID) FULL OUTER JOIN REGIONS USING(REGION_ID)
WHERE REGION_NAME = 'Asia';

SELECT city, country_name
FROM locations JOIN countries USING (country_id) JOIN regions using (region_id)
WHERE region_name = 'Asia';

--20
SELECT department_name ,SALARY 
FROM EMPLOYEES JOIN DEPARTMENTS  USING(DEPARTMENT_ID)
WHERE SALARY >= 4000;

SELECT department_name ,SALARY 
FROM EMPLOYEES LEFT OUTER JOIN DEPARTMENTS  USING(DEPARTMENT_ID)
WHERE SALARY >= 4000;

-- 21
SELECT DEPARTMENT_NAME ,AVG(SALARY)
FROM EMPLOYEES JOIN DEPARTMENTS  USING(DEPARTMENT_ID)
GROUP BY DEPARTMENT_NAME 
HAVING AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEES );

-- 22
SELECT PHONE_NUMBER 
FROM EMPLOYEES 
WHERE SALARY = (SELECT MAX(SALARY)FROM EMPLOYEES);

--23
SELECT FIRST_NAME ,JOB_TITLE
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) JOIN LOCATIONS USING(LOCATION_ID) JOIN JOBS USING(JOB_ID)
WHERE CITY = 'Seattle' AND SUBSTR(FIRST_NAME,-1,1) = 'l'

--24
SELECT SUBSTR(HIRE_DATE,1,2) ,COUNT(HIRE_DATE)
FROM EMPLOYEES
GROUP BY SUBSTR(HIRE_DATE,1,2) 

SELECT to_char(hire_date, 'yyyy') AS year, count(hire_date) AS num FROM employees
GROUP BY to_char(hire_date, 'yyyy')
ORDER BY to_char(hire_date, 'yyyy');


--25 
SELECT COUNT(*)
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID) JOIN LOCATIONS USING(LOCATION_ID) JOIN COUNTRIES USING(COUNTRY_ID)
WHERE COUNTRY_NAME = 'Canada';

--26 직업변경 어케암??
SELECT EMPLOYEE_ID ,FIRST_NAME ,HIRE_DATE ,SALARY ,DEPARTMENT_NAME 
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)
WHERE EMPLOYEE_ID NOT IN 
(SELECT EMPLOYEE_ID  FROM JOB_HISTORY )

--27
SELECT COUNT(*)
FROM EMPLOYEES 
WHERE COMMISSION_PCT IS NULL
GROUP BY DEPARTMENT_ID ;

--28
SELECT FIRST_NAME ,PHONE_NUMBER ,EMAIL
FROM EMPLOYEES 
WHERE PHONE_NUMBER LIKE '011%';

SELECT FIRST_NAME ,PHONE_NUMBER ,EMAIL
FROM EMPLOYEES 
WHERE SUBSTR(PHONE_NUMBER,1,3) = '011';

-- 29
SELECT *
FROM EMPLOYEES 
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME = 'Britney')
AND JOB_ID IN (SELECT JOB_ID FROM EMPLOYEES WHERE FIRST_NAME = 'Britney');
-- == 같다 
SELECT *
FROM EMPLOYEES 
WHERE (DEPARTMENT_ID,JOB_ID) = (SELECT DEPARTMENT_ID,JOB_ID FROM EMPLOYEES WHERE FIRST_NAME = 'Britney')

-- 30 두개다 있어서 애매하다 
SELECT DEPARTMENT_ID ,DEPARTMENT_NAME 
FROM EMPLOYEES E JOIN DEPARTMENTS D USING(DEPARTMENT_ID)
WHERE EMPLOYEE_ID IN (SELECT D.MANAGER_ID 
FROM EMPLOYEES E JOIN DEPARTMENTS D USING(DEPARTMENT_ID)
WHERE DEPARTMENT_NAME = 'IT')
AND (SELECT AVG(SALARY)FROM EMPLOYEES) > (SALARY*12+NVL(COMMISSION_PCT,0));

SELECT DEPARTMENT_ID ,DEPARTMENT_NAME ,AVG(SALARY)
FROM DEPARTMENTS JOIN EMPLOYEES USING(DEPARTMENT_ID)
GROUP BY DEPARTMENT_ID ,DEPARTMENT_NAME 
HAVING AVG(SALARY *12 + SALARY * NVL(COMMISSION_PCT,0)) > 
(SELECT SALARY *12 + SALARY * NVL(COMMISSION_PCT,0)
FROM EMPLOYEES 
WHERE EMPLOYEE_ID  = 
	(SELECT MANAGER_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'IT'))